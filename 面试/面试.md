## CSS面试题

### CSS属性继承

#### CSS中哪些属性是可以继承的

字体：font、font-family、font-size、font-style、font-variant、font-weight

文字展示：line-height、text-align、text-indent、text-transform(控制文本大小写)

字母间距：letter-spacing

可见性：visibility

字间距：word-spacing

### 如何区分px/em/rem/vw/vh

#### px/em/rem/vw/vh的概念

px：就是pixel像素的缩写，可以简单理解为网页开发的基本长度单位

em：em是一个相对长度单位，相对于当前元素内文本的字体尺寸

rem：rem是CSS3新增的一个相对单位，基于html元素的字体大小来决定，通常配合媒体查询用于解决移动端适配问题。

vw和vh：vw和vh是相对于(浏览器)视口的长度单位，1vw即值为视口宽度的1%，1vh意味着值为视口高度的1%。

#### px/em/rem之间的转换

1em=盒子内字体的大小

10em=10×font-size(盒子内)

如：盒子中字体大小为20px，盒子的宽度为10em，即10×20=200px

1rem=html中字体大小

2rem=2×font-size(html中)

如：html元素字体大小为100px，盒子的宽度为2rem，即2×100=200px

#### 面试口诀

面试口诀：一绝三相

px：绝对单位，网页开发基本长度单位

em：相对单位，相对当前盒子字体大小进行计算（没给的话就是浏览器默认字体16px）

rem：相对单位，相对根元素html字体大小进行计算（没给的话就是浏览器默认字体16px）

vw+vh：相对单位，相对当前网页视口宽度和高度进行计算

#### em和rem的使用场景

- em：通常用于字体缩进
- rem：配合媒体查询处理移动端适配问题

### CSS如何实现左边定宽，右边自适应？

#### 非严格意义实现方案

左边盒子的宽度发生改变，右边的盒子宽度不会相应地变化

（1）float+calc(需要手动计算右边盒子计算属性中的宽度)

```html
<body>
    <div class="box-wrapper">
        <div class="left-box">
            left-box
        </div>
        <div class="right-box">
            right-box
        </div>
    </div>
</body>
```

```css
<style>
* {
    margin: 0;
    padding: 0
}
.box-wrapper {
    width: 600px;
    height: 400px;
    border: 1px solid #000;
}
.left-box {
    float: left;
    width: 200px;
    height: 100%;
    background: red;
}
.right-box {
    float: right;
    width: calc(100% - 200px);  // 当左边盒子宽度修改时，右边盒子宽度也需要手动改一下
    height: 100%;
    background: blue;
}
</style>
```



（2）inline-block+calc

```css
<style>
.box-wrapper {
    width: 600px;
    height: 400px;
    border: 1px solid #000;
}
.left-box {
    display: inline-block;
    width: 200px;
    height: 100%;
    background: red;
}
.right-box {
    display: inline-block;
    width: calc(100% - 200px);  // 当左边盒子宽度修改时，右边盒子宽度需要手动修改才能达到真正的自适应
    height: 100%;
    background: blue;
}
</style>
```



（3）position+padding

```css
<style>
.box-wrapper {
    width: 600px;
    height: 400px;
    position: relative;
    border: 1px solid #000;
}
.left-box {
    width: 200px;
    height: 100%;
    background: red;
    position: absolute;
}
.right-box {
    padding-left: 200px;  // 当左边盒子宽度修改时，右边盒子宽度需要手动修改padding-left才能达到真正的自适应
    height: 100%;
    background: blue;
}
</style>
```



#### 严格意义实现方案

左边盒子的宽度发生改变，右边盒子会自动撑满剩余的空间

（1）flex布局

```css
<style>
.box-wrapper {
    width: 600px;
    height: 400px;
    border: 1px solid #000;
    display: flex;
}
.left-box {
    width: 200px;
    height: 100%;
    background: red;
}
.right-box {
    background: blue;
    flex: 1;// 无论左边盒子宽度如何修改，右边盒子都会占满剩余的空间
}
</style>
```



（2）table布局

```css
<style>
.box-wrapper {
    width: 600px;
    height: 400px;
    border: 1px solid #000;
    display: table;
}
.left-box {
    width: 200px;
    height: 100%;
    background: red;
    display: table-cell;
}
.right-box {
    height: 100%;
    background: blue;
    display: table-cell; // 无论左边盒子宽度如何修改，右边盒子都会占满剩余的空间
}
</style>
```



（3）grid布局

```css
<style>
.box-wrapper {
    width: 600px;
    height: 400px;
    border: 1px solid #000;
    display: grid;
    /* 声明列的宽度 */
    grid-template-columns: 200px auto; // left-box的宽度是200px，right-box的宽度是auto 
}
.left-box {
    background: red;
}
.right-box {
    background: blue;
}
</style>
```

### CSS如何实现绝对居中

#### 定宽高

（1）绝对定位+负margin值

```html
<div class="box-wrapper">
    <div class="box">
        /* box盒子的宽高是固定的 */
    </div>
</div>
```

```css
.box-wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid red;
    /* 关键因素 */
    position: relative;
}
.box {
    width: 100px;
    height: 100px;
    background: blue;
    /* 关键因素 */
    position: absolute;
    left: 50%;
    top: 50%;
    margin-left: -50px;
    margin-top: -50px;
}
```



（2）绝对定位+margin auto

```css
.box-wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid red;
    /* 关键因素 */
    position: relative;
}
.box {
    width: 100px;
    height: 100px;
    background: blue;
    /* 关键因素 */
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}
```



#### 不定宽高

（1）绝对定位+transform

```html
<div class="box-wrapper">
    <div class="box">
        /* box盒子的宽高是不固定的 */
    </div>
</div>
```

```css
.box-wrapper {
    width: 200px;
    height: 200px;
    border: 1px solid red;
    /* 关键因素 */
    position: relative;
}
.box {
    background: yellow;
    /* 关键因素 */
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%)
}
```

（2）table-cell

```css
.box-wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid red;
    /* 关键因素 */
    dispaly: table-cell;
    vertical-align: middle;
    text-align: center;
}
.box {
    background: yellow;
    /* 关键因素 */
    display: inline-block;
}
```

（3）flex布局

```css
.box-wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid red;
    /* 关键因素 */
    dispaly: flex;
    justify-content: center;  // 定义内部盒子在水平方向上的排列方式为居中
    align-items: center;  // 定义内部盒子在垂直方向上的排列方式为居中
}
.box {
    background: yellow;
}
```

### 清除浮动

#### 为什么要清除浮动？

由于父级盒子很多情况下，不方便给高度，但是盒子浮动又不占用位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。由于浮动元素不再占用原文档流的位置，所以它对后面的元素排版产生影响。

#### 清除浮动有哪些方法？各有什么优缺点？

##### 父元素固定宽高

优点：简单，代码量少，没有兼容问题

缺点：内部元素高度不确定的情况下无法使用

```html
<div class="box-container">
    <img src="./image/js.jpg">
    <div class="right-box">
        <div class="right-box-title">前端开发工程师</div>
        <div class="right-box-content">综合就业率第一</div>
    </div>
</div>
```

```css
.box-container {
    width: 142px;
    height: 45px;  // 给父元素固定高度
    padding: 10px;
    boeder: 1px solid red;
}
img {
    width: 45px;
    height: 45px;
    float: left;
    margin-right: 10px;
}
.right-box {
    float: right;
}
```



##### 添加新元素

优点：简单，代码量少，没有兼容性问题

缺点：需要添加无语义的html元素，代码不够优雅，不便于后期的维护

```html
<div class="box-container">
    <img src="./image/js.jpg">
    <div class="right-box">
        <div class="right-box-title">前端开发工程师</div>
        <div class="right-box-content">综合就业率第一</div>
    </div>
    <!-- 添加新元素，利用css提供的clear: both清除浮动 -->
    <div class="clear-element"></div>
</div>
```

```css
.box-container {
    width: 142px;
    padding: 10px;
    boeder: 1px solid red;
}
img {
    width: 45px;
    height: 45px;
    float: left;
    margin-right: 10px;
}
.right-box {
    float: right;
}
/* 清除浮动：添加新元素 */
.clear-element {
    clear: both;
}
```



##### 使用伪元素

优点：仅用css实现，不容易出现怪问题

缺点：仅支持IE8以上和非IE浏览器

```css
.box-container {
    width: 142px;
    padding: 10px;
    boeder: 1px solid red;
}
/* 对父元素添加伪元素 */
.box-container::after {
    content: "";
    display: block;
    height: 0;
    clear: both;
}
img {
    width: 45px;
    height: 45px;
    float: left;
    margin-right: 10px;
}
.right-box {
    float: right;
}
```



##### 触发父元素BFC

优点：仅用CSS实现，代码少，浏览器支持好

缺点：用overflow：hidden触发BFC情况下，可能会使内部本应正常显示的元素被裁剪

```css
.box-container {
    width: 142px;
    padding: 10px;
    boeder: 1px solid red;
    /* overflow: hidden; */
    float: left;
    /* position: absolute; */
    /* display: inline-block */
    /* 以上属性均可触发BFC */
}

img {
    width: 45px;
    height: 45px;
    float: left;
    margin-right: 10px;
}
.right-box {
    float: right;
}
```



#### 面试官主要考察什么？

（1）是否实际使用过浮动布局？

（2）清除浮动局部场景下的知识深度和广度？

深度：不仅可以实现清除浮动，还知道它的优缺点

广度：可以用多种方式来实现

（3）面对问题的专研精神

#### 面试中遇到该问题我们该如何回答？

（1）举出清除浮动的具体场景（引用本小节的例子）

（2）至少说出本小节的4种实现方案并分析优缺点

### CSS三角形

#### 用CSS画三角形的场景有哪些？

#### 如何用CSS画一个三角形？

```html
<div class="triabgle"></div>
```

```css
<style>
	.triangle {
    	border: 10px solid transparent;
        border-left: 10px solid #f40;
	}
</style>
```



#### 面试官主要考察什么？

（1）CSS基本功如何？

能否实现css画三角形

（2）针对css性能是否有自己的思考？

为什么要用css画三角形，好处是什么？

#### 面试中遇到该题目该如何回答？

（1）说出CSS画三角形的实现方案

（2）扩展至CSS实现圆形，箭头，扇形的场景

（3）说出为什么要用CSS画三角形的原因

出于页面性能考虑，避免发送过多的http请求，节省带宽

### CSS提高页面性能

#### CSS提高页面性能的方法有哪些？

（1）属性设置使用简写

```css
p {
    margin-top: 10px;
    margin-right: 20px;
    margin-bottom: 30px;
    margin-left: 40px;
}
/* 简写 */
p {
    margin: 10px 20px 30px 40px;
}
```

（2）用CSS替换图片

- 用CSS画三角形
- 用CSS画箭头
- 用CSS画圆形

（3）删除不必要的零和单位

```css
/* 优化前写法 */
.box {
    width: 0.2em;
    height: 20.0em;
    padding: 0px;
}
/* 优化后写法 */
.box {
    width: .2em;
    height: 20em;
    padding: 0;
}
```

（4）用CSS精灵图替代单个文件加载

精灵图中包含很多图标，仅仅用到背景定位就可以拿到想要的图标。方案的优势：用一个HTTP请求替代多个HTTP请求。

#### 面试官主要考察什么？

（1）CSS技术深度广度的了解

掌握本小节4种CSS性能优化方案

（2）在CSS层面对项目性能关注度

掌握本小节4种CSS性能优化方案

#### 面试中遇到该问题该如何回答？

1、属性简写     目的：减小生产包体积

2、图标替换     目的：减少http请求节约带宽

3、删除零和单位     目的：减少生产包体积

4、背景图使用精灵图     目的：减少http请求节约带宽

### 章总结

1、你对盒子模型理解多少？

（1）什么是盒模型？CSS基础框盒模型是CSS规范的一个模块，它定义了一种长方形的盒子。

（2）盒模型的分类：盒模型从标准定义上分为标准盒模型和替代(IE)盒模型，从元素类型上分为块级盒子和内联盒子。

（3）盒模型的切换：

通过box-sizing属性进行切换：

ie盒模型：box-sizing：border-box；

标准盒模型：box-sizing：border-content；

（4）盒模型属性设置：

margin和padding值的设置：

1个值的情况：如10px 4个方向都为10px；

2个值的情况：如10px 20px  上下10px  左右20px

3个值的情况：如10px 20px 30px  上10px  左右20px  下30px

4个值的情况：如10px 20px 30px 40px 上10px 右20px 下30px 左40px(顺时针)

border值：border：1px solid red；三个值分别代表border-width，border-style，border-color，可设置一个或多个属性的值

2、谈谈你对BFC的理解？

（1）什么是BFC？

BFC是Block Formatting Context，块格式化上下文的缩写，简单的说BFC是一个完全独立的空间，这个空间里子元素的渲染不会影响到外面的布局。

（2）如何创建BFC？（可以触发生成BFC的条件有哪些？）

常见的几种如下：

```css
display: table-cell;
display: flex;
overflow: hidden;
position: absolute;
position: fixed
```

（3）BFC解决了什么问题？

- 垂直方向margin重叠的问题。
- 使用Float脱离文档流，父元素高度塌陷问题。

3、谈谈你对CSS选择器的理解？

（1）CSS选择器是什么？

通俗的讲CSS选择器用来对选定的页面元素进行样式修改。

（2）CSS选择器有哪些？

CSS选择器从种类上可以分为11种：

| 选择器                   | 示例              |
| ------------------------ | ----------------- |
| 元素选择器（标签选择器） | h1 { }            |
| 通配符选择器             | * { }             |
| 类选择器                 | .box { }          |
| ID选择器                 | #unique { }       |
| 标签属性选择器           | a[title] { }      |
| 伪类选择器               | p:first-child     |
| 伪元素选择器             | p::first-line { } |
| 后代选择器               | article p         |
| 子代选择器               | article>p         |
| 相邻兄弟选择器           | h1 + p            |
| 通用兄弟选择器           | h1 ~ p            |

4、谈谈你对CSS选择器优先级的理解？

（1）什么是CSS选择器优先级：CSS选择器优先级是基于不同种类选择器组成的匹配规则

（2）CSS选择器的优先级：!important > 行内样式 > ID选择器 > 类、伪类、属性选择器 > 标签、伪元素选择器 > 通配符、子类选择器、兄弟选择器

5、CSS中哪些属性是可以继承的？

（1）什么是CSS的属性继承？CSS属性继承指的是，特定的css属性可以向下传递到后代元素

（2）CSS中常见的可继承属性有哪些？

6、如何区分px/em/rem/vw/vh？

7、CSS如何实现左边定宽，右边自适应？

（1）什么是左边定宽度右边自适应布局？

外层盒子宽度确定情况下，左侧盒子宽度不固定，右边盒子宽度自适应。

（2）如何实现左边定宽，右边自适应布局？

8、CSS如何实现绝对居中？

（1）什么是绝对居中（水平垂直居中）？

内外两个盒子，内侧盒子相对外侧盒子水平垂直方向都居中。

（2）如何实现绝对水平居中（水平垂直居中）？

9、清除浮动有哪些方法，各有什么优缺点？

（1）举出清除浮动的具体场景

（2）至少说出4种实现方案并分析他们的优缺点

10、如何用css画一个三角形

（1）说出css画三角形的实现方案

css实现三角形的核心是用无宽高盒子的border

- 透明边框：第一步四个方向全部透明边框，
- 箭头方向：第二步选择箭头方向，箭头指向和有色边框方向相反

（2）说出为什么要用css画三角形的原因

- 处于页面性能考虑，避免发送过多的http请求，节省带宽

11、CSS实现三栏布局有哪些方法？

12、如果要做优化，CSS提高性能的方法有哪些？



## JS面试题

### bind、call、apply

#### 为什么把bind，call，apply放在一起？

```js
// 小王去面试
// 小王去招聘会现场参加面试 招聘的企业是腾讯和阿里
// 腾讯和阿里的面试官分别是freemen和vinko，阿里的vinko临时有事，请腾讯的freemen来帮忙
// freemen来到阿里的面试现场说 你好我是vinko，我的公司是阿里
const Tencent = {
    name: "freemen",
    time: "2021-11-31",
    address: "Beijing",
    say(company) {
        console.log(`my name is`, this.name);
        console.log(`my company is`, company);
    }
}
const Alibaba = {
    name: "vinko",
    time: "2021-11-31",
    address: "Beijing",
    say(company) {
        console.log(`my name is`, this.name);
        console.log(`my company is`, company);
    }
}
// 腾讯的面试现场
Tencent.say('Tencent'); // my name is freemen my company is Tencent
// 腾讯的面试官替阿里的面试官面试
Tencent.say.call(Alibaba, 'Alibaba');  // my name is vinko my company is Alibaba
Tencent.say.apply(Alibaba, ['Alibaba']); // my name is vinko my company is Alibaba
const say = Tencent.say.bind(Alibaba, 'Alibaba'); // bind返回的是一个函数，需要接收一下
say();  // my name is vinko my company is Alibaba
```



#### bind，call，apply有什么区别？

相同点：bind，call，apply都可以改变this指向

不同点：

（1）call和apply的传参方式不同，call是多个参数以逗号形式隔开挨个传递，apply是以数组形式传递参数

（2）bind和call，apply的返回值不同，bind返回值是函数，当调用这个返回的函数时，函数才会被执行；call和apply返回的是一个函数调用，call和apply改变this指向之后函数会立即执行。

#### bind，call，apply的使用场景？

**call的使用场景**

（1）判断数据类型

```js
const array = [1,2,3,4];
const type = Object.prototype.toString.call(array);
console.log(`type`,type); // type [object Array]
```

（2）类数组转数组

```js
const arrayLike = {
    0: "name",
    1: "age",
    2: "gender",
    length: 3
}
const res = Array.prototype.slice.call(arrayLike)
console.log(`res`,res);  // res ['name','age','gender']
```

**apply的使用场景**

（1）对给定数组求最大值/最小值

```js
const array = [1,2,3,4,5];
const max = Math.max.apply(null,array); // Math.max(1,2,3,4,5)
console.log(`max`,max) // max 5
```

**bind的使用场景**

react类组件事件响应函数的绑定

```js
class App extends React.Component {
    constructor(props) {
        super(props);
        this.name = 'freemen';
        this.handleClick = this.handleClick.bind()
    }
    handleClick() {
        console.log(`this`,this.name)
    }
    render() {
        return (
        	<button onClick="{this.handleClick}">点击</button>
        )
    }
}
```

#### 面试官主要考察什么？

（1）是否知道js中的bind，call，apply函数？

（2）是否知道js中的bind，call，apply函数之间的区别？

（3）是否在实际场景中使用过bind，call，apply？

#### 面试中遇到该题目该如何回答？

（1）说出bind，call，apply函数是干啥的？

bind，call，apply都是用来改变this指向的

（2）说出bind，call，apply的区别？

- call和apply的传参方式不同，call是多个参数以逗号形式隔开挨个传递，apply是以数组形式传递参数
- bind和call，apply的返回值不同，bind返回值是函数，当调用这个返回的函数时，函数才会被执行；call和apply返回的是一个函数调用，call和apply改变this指向之后函数会立即执行。

（3）谈一谈bind，call，apply的实现原理

### 数组去重

#### js数组去重的场景

```js
// [1,2,3,4,5,2,3]
// [{name: "freemen",age: "20"},{name: "mukewang",age: "20"}]
// indexOf  查找项，返回坐标，不存在返回-1
// filter []
// sort []
// reduce []
// push   length
const array = [1,2,3,4,5];
const res = array.indexOf(2);
console.log(res); // 1

const res1 = array.filter((item,index)=>{
    return item%2===0
})
console.log(res1); // [2,4]

const res2 = array.sort((a,b)=>{
    return a-b;
})
console.log(res2); // [1,2,3,4,5]

const res3 = array.sort((a,b)=>{
    return b-a;
})
console.log(res2); // [5,4,3,2,1]

const res3 = array.reduce(function(prev,current,currentIndex,sourceArray) {
    return prev+current
})
console.log(res3); // 15

const res4 = array.push(1);
console.log(res4); // 6
console.log(array); [1,2,3,4,5,6]
```

#### 如何使用多种方式实现数组去重？

**普通数组去重**

- filter+indexOf方法去重
- 相邻元素排序
- set与解构赋值去重
- set与Array.from去重

```js
// 普通数组的去重
const array = [1,2,3,4,5,2,3];
// 方法1：filter+indexOf
function unique(array) {
    if(!Array.isArray(array)) {
        throw new Error("unique function params is not Array")
    }
    return array.filter((item,index)=>{
        return array.indexOf(item) === index;
    })
}
const res = unique(array);
console.log(res); // [1,2,3,4,5]
// 方法2：相邻元素排序
function unique(array) {
    array = array.sort()
    let res = [];
    for(let i = 0; i <array.length; i++) {
        if(array[i] != array[i-1]) {
            res.push(array[i])
        }
    }
    return res;
}
const res = unique(array);
console.log(res); // [1,2,3,4,5]
// 方法3：Set 解构赋值
function unique(array) {
    return [...new Set(array)]
}
const res = unique(array);
console.log(res); // [1,2,3,4,5]
// 方法4：set Array.from
function unique(array) {
    return Array.from(new Set(array))
}
const res = unique(array);
console.log(res); // [1,2,3,4,5]
```

对象数组去重

- 临时对象缓存数组项key值
- reduce方法+缓存对象

```js
// 对象数组的去重
const array = [{name: "freemen",age: "20"},{name: "mukewang",age: "20"}]
// 方法1：临时对象缓存数组项key值
function unique(array,key) {
    let result = [];
    let template = {}
    for (let i = 0; i < array.length; i++) {
        var keyName = array[i][key];
        if(template[keyName]) {
            continue;
        }
        template[keyName] = true;
        result.push(array[i]);
    }
    return result;
}
const res = unique(array,'age');
console.log(res);  // [{name: "freemen",age: "20"}]
// 方法2：reduce
function unique(array,key) {
    var cacheObj = {}
    return array.reduce((prev,current)=>{
        cacheObj[current[key]] ? "" : cacheObj[current[key]]=true&&prev.push(current)
        return prev;
    },[])
}
const res = unique(array,'age');
console.log(res);  // [{name: "freemen",age: "20"}]
```

#### 面试官主要考察什么？

（1）是否熟悉数组的常用方法和基本操作

（2）能否用多种方式实现数组去重

#### 面试中遇到该题目该如何回答？

（1）说出/写出js实现去重的多种方式（普通数组，对象数组）

（2）方法中涉及到数组实例方法和原型方法的情况介绍下他们的使用方法（返回值）和场景，如：push，filter

### 对给定数组求最大值

#### 对给定数组求最大值的场景

#### 怎样对给定数组求最大值

1、Math.max

```js
const array = [1,2,3,4,5];
const res = Math.max(...array);
const res1 Math.max.apply(null,array);
console.log(res); // 5,res1=5
```

2、数组的reduce函数

```js
function getMax(array) {
    return array.reduce((prev,current)=>{
        return current > prev ? current : prev;
    })
}
const res = getMax(array);
console.log(res); // 5
```

3、数组的sort函数

```js
function getMax(array) {
    const result = array.sort()
    return result[result.length - 1]
}
const res = getMax(array);
console.log(res); // 5
```

#### 面试官主要考察什么

（1）基本的数据处理能力

#### 面试中遇到该题目该如何回答

（1）说出对给定数组求最大值的实现方案

（2）方法中涉及到数组的原型方法的情况介绍下他们的使用方法（返回值）和场景

### js中判断数据类型

#### js中判断数据类型的场景？

#### js中的数据类型有哪些？

- 基本数据类型

  String、Number、Boolean、Symbol、undefined、Null

- 引用数据类型

  Object、Array、Function、Date、FormData、Set、Map等等

#### js中判断数据类型的方式有哪些？

- typeof

  优点：使用简单

  缺点：功能残缺，

  只能用来判断6种数据类型：String、Number、Boolean、Symbol、undefined、Function

  ```js
  const array = [];
  const object = {};
  const number = 1;
  const string = 'string';
  
  const type = typeof array;
  console.log(type);// object
  const type1 = typeof number;
  console.log(type1);// number
  ```

  

- Object.prototype.toString.call

  优点：适用于判断所有数据类型

  缺点：使用上相对typeof而言比较繁琐

  ```js
  const array = [];
  const object = {};
  const number = 1;
  const string = 'string';
  
  const type = Object.prototype.toString.call(array);
  console.log(type);// [object Array]
  const type1 = Object.prototype.toString.call(object);
  console.log(type1);// [object Object]
  const type2 = Object.prototype.toString.call(number);
  console.log(type2);// [object Number]
  const type3 = Object.prototype.toString.call(string);
  console.log(type3);// [object String]
  ```

- instanceof（排除）

  instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上

#### 面试中遇到该题目该如何回答？

- js中判断数据类型的场景？

  根据接口返回参数类型做区别处理。

- js中的数据类型有哪些？

  （1）基本数据类型

  String、Number、Boolean、Symbol、undefined、Null

  （2）引用数据类型

  Object、Array、Function、Date、FormData、Set、Map等等

- js中判断数据类型的方式有哪些？（优缺点，谈及instanceof）

### 函数节流

#### 什么是函数节流？

规定在一个**单位时间内**，事件响应函数只能被触发一次。如果这个单位时间内触发多次函数，**只有一次生效**。

#### 函数节流的使用场景？

- window.onresize事件

  ```js
  // 关键点 1 单位时间内 2 只触发一次
  // 1 返回值是一个函数
  // 2 开启定时器
  // 3 如果定时器存在直接返回false
  // 4 定时器内部清空定时器，并且把timer置为null，然后执行事件响应函数
  function throttle(fn, interval) {
      let timer;
      return (event)=>{
          if(timer) {
              return false;
          }
          timer = setTimeout(()=>{
              clearTimeout(timer);
              timer = null;
              fn(event);
          }, interval)
      }
  }
  window.onresize = throttle(function(event) {
      console.log(`event`,event)
  },1000)
  ```

  

- mousemove事件

#### 如何实现函数节流？

```js
// 1 返回值是一个函数
// 2 开启定时器
// 3 如果定时器存在直接返回false
// 4 定时器内部清空定时器，并且把timer置为null，然后执行事件响应函数
function throttle(fn, interval) {
    let timer;
    return (event)=>{
        if(timer) {
            return false;
        }
        timer = setTimeout(()=>{
            clearTimeout(timer);
            timer = null;
            fn(event);
        }, interval)
    }
}
```



#### 面试官主要考察什么？

（1）是否知道函数节流的概念

（2）是否知道函数节流的具体使用场景

（3）是否对项目本身的性能有所关注

#### 面试中遇到该题目该如何回答？

（1）说出函数节流的概念

规定在一个单位时间内，事件响应函数只能触发一次。如果这个单位时间内触发多次函数，只有一次生效。

（2）举出函数节流的具体应用场景

window.onresize/mousemove事件监听

（3）说出/写出函数节流的实现方式

### 函数防抖

#### 什么是函数防抖？

函数防抖：事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

#### 函数防抖的使用场景？

搜索框（电商网站商品搜索，后台管理系统数据查询）

#### 如何实现函数防抖？

```js
const searchElement = document.getElementById("searchElement");
// 1. 返回值是一个函数
// 2. 固定间隔执行事件响应函数
const debounce = (fn,interval)=>{
    let timer = null;
    return ()=>{
        clearTimeout(timer);
        timer = setTimeout(fn,interval)
    }
}
searchElement.oniput = debounce(function(event) {
    const value = searchElement.value()
    console.log(value);
},1000)
```



#### 面试官主要考察什么？

（1）是否知道函数防抖的概念

（2）是否知道函数防抖的具体使用场景

电商平台搜索商品的输入框需要加一个函数防抖，来减少http请求，节省服务器带宽

（3）是否对项目本身的性能有所关注

#### 面试中遇到该题目该如何回答？

（1）说出函数防抖的概念

事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

（2）举出防抖的具体使用场景

搜索框（电商网站商品搜索，后台管理系统数据查询）

（3）说出/写出函数防抖的实现方式

### 数组拍平

#### 什么是数组拍平？

数组拍平也叫**数组扁平化、数组拉平、数据降维**。指的是把多维数组变成一维数组。

#### 数组拍平的使用场景？

- 复杂场景下的数据处理（echarts做大屏数据展示）

#### 如何实现数组拍平？

（1）reduce函数

```js
const array = [1,2,3,4,[5,6,[7,8]]]
// array  [1,2,3,4,5,6,7,8]

function flatten(array) {
    return array.reduce(function(prev,current) {
        return prev.concat(Array.isArray(current) ? flatten(current) : current)
    },[])
}
const res = flatten(array);
console.log(res)
```

（2）es6自带的flat函数

```js
const array = [1,2,3,4,[5,6,[7,8]]]
// array  [1,2,3,4,5,6,7,8]

function flatten(array) {
    return array.flat(Infinity)
}
const res = flatten(array);
console.log(res)
```

（3）用while循环加扩展运算符

```js
const array = [1,2,3,4,[5,6,[7,8]]]
// array  [1,2,3,4,5,6,7,8]

function flatten(array) {
    while(array.some(Array.isArray)) {
        array = [].concat(...array)
    }
    // 1 array是一维数组
    // 2 已经被拍平
    return array;
}
const res = flatten(array);
console.log(res)
```



#### 面试官主要考察什么？

（1）手写代码的能力

（2）基本的数据处理能力

#### 面试中遇到该题目该如何回答？

（1）写出数组拍平的三种实现方案

（2）举出数组拍平的使用场景（Eachrts做图/非必要）

### 怎样使如下判断成立

```js
let value = 0;
Object.defineProperty(window, 'a', {
    get() {
        return value += 1;
    }
})
if(a===1&&a===2&&a===3) {
    console.log('object');
} // 正常输出object
```

### new 操作符

```js
// 实例化对象
const TMap = function(options) {
    this.name = options.name;
    this.address = options.address; 
}
const map = new TMap({
    name: 'tmap',
    address: "BJ"
})
console.log('map : >>',map); // map : >> TMap  {name: 'tmap', address: 'BJ'}
```

```js
// 返回值的问题：构造函数中如果有值返回，那实例化后的对象就是这个返回值
const TMap = function(options) {
    this.name = options.name;
    this.address = options.address; 
    return {
        name: "map",
        address: "SZ"
    }
}
const map = new TMap({
    name: 'tmap',
    address: "BJ"
})
console.log('map : >>',map); // map : >> TMap  {name: 'map', address: 'SZ'}
```

#### 如何实现new操作符

```js
const ObjectFactory = (...args)=> {
    // 1. 创建空对象
    const obj = {};
    // 2. 获取构造函数
    const Constructor = [].shift.call(args)
    // 3. 对象的__proto__指向Constructor.prototype
    obj.__proto__ = Constructor.prototype;
    // 4. 用apply的方式把构造函数Constructor的this指向obj 执行Constructor
    const ret = Constructor.apply(obj,args)
    // 5. 根据ret的执行结果判断返回构造函数的返回对象还是新创建的空对象
    return typeof ret === 'object' ? ret : obj;
}
const map = ObjectFactory(TMap,{name: "MAP",address: "BJ"})
console.log('map : >>',map); // map : >> TMap  {name: 'map', address: 'SZ'}
```

#### 面试官主要考察什么

（1）是否在实际项目中使用过new操作符

（2）是否可以实现一个new操作符（js基础知识是否扎实）

#### 面试中遇到该问题该如何回答

（1）说出new操作符的实际使用场景及实现原理

使用场景：用来封装一些第三方的工具，比如腾讯地图，高度地图，eachrts等，都可以用new操作符通过构造函数的方式进行封装，封装好之后用new实例化对象

（2）写出完整的实现原理

### 实现bind函数

```js
function origin(a,b) {
    console.log(this.name);
    console.log([a,b]);
}
const obj = {
    name: "freemen"
}
const func = origin.bind(obj,2);
func(1); // freemen [2,1]
```

```js
Function.prototype.bindFn = function() {
    // 获取源函数
    const fn = this;
    // 获取目标对象
    const obj = arguments[0];
    // 获取源函数参数列表
    const args = [].slice.call(arguments,1)
    // 返回函数
    return function() {
        // 获取返回函数的参数列表
        const returnArgs = [].slice.call(arguments);
        // 执行源函数
        fn.apply(obj,args.concat(returnArgs));
    }
}
```

#### 面试中遇到该问题该如何回答

（1）说出或者写出bind函数的实现原理（bind心法4步走）

1、bind函数改变this指向

2、bind函数是Function.prototype上的方法

3、bind函数的返回值也是函数

4、bind函数调用之后返回的函数的参数同样也接收处理

### 实现instanceof

instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。

```js
function Person() {
    this.name = "freemen"
}

const obj = new Person
console.log(obj instanceof Person) // true
```

#### 面试中遇到该问题该如何回答

（1）说出或者写出instanceof函数的实现原理

1、获取实例对象的隐式原型

2、获取构造函数的prototype属性

3、while循环 -> 在原型链上不断向上查找

4、在原型链上不断查找 构造函数的显示原型

5、直到implicitPrototype = null 都没找到，返回false

6、构造函数的prototype属性出现在实例对象的原型链上  返回true

### 章总结

1、你对原型和原型链的了解有多少？

- 什么是原型和原型链

  在javaScript中，函数可以有属性。每个函数都有一个特殊的属性叫原型(prototype)

  原型链就是当我们访问对象的某个属性或方法时，如果在当前对象中找不到定义，会继续在当前对象的原型对象中查找，如果原型对象中依然没有找到，会继续在原型对象的原型中查找（原型也是对象，也有它自己的原型）如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回undefined。可以看出，这个查找过程是一个链式的查找，每个对象都有一个它自身原型对象的连接，这些连接组件的整个链条就是原型链。

- 原型和原型链存在的意义是什么？

  使得实例对象可以共享构造函数原型属性和方法，节省内存。构造函数原型上的属性和方法越多，节省内存越大。

2、如何理解作用域和作用域链

- 什么是作用域

  作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性，作用域决定了代码区块中变量和其他资源的可见性。

- 作用域存在的意义是什么？

  作用域存在的最大意义就是变量隔离 即：不同作用域下同名变量不会有冲突。

- 什么是作用域链

  当我们在某个函数内部作用域中查找某个变量时，如果没有找到就会到他的父级作用域中查找，如果父级也没找到就会接着一层一层的向上查找，直到找到全局作用域还是没找到的话，就宣布放弃。这种一层一层的作用域嵌套关系，就是作用域链。

3、你对闭包的理解

- 什么是闭包？

  大白话：能够访问其他函数内部变量的函数，被称为闭包。

- 闭包有哪些实际的使用场景？

  （1）事件函数的封装

  （2）用闭包模拟私有方法

  （3）在循环中给页面元素绑定事件响应函数

- 闭包存在什么问题？

  闭包本身会造成内存变量常驻内存



## ES6面试题

### let const和var的区别

（1）let和const声明变量时不存在变量提升

（2）let块级作用域

（3）暂时性死区(用let声明变量之前不可以对变量进行赋值)

（4）let不可重复声明变量

（5）用let和const声明的变量不会挂在window上

（6）const声明变量后必须立马对其赋值，否则会报错

（7）const声明简单类型的变量值不可更改，复杂类型内部数据可以更改

### 箭头函数和普通函数的区别

（1）箭头函数的this指向父级作用域的this

（2）call()/.apply()/.bind()无法改变箭头函数中this的指向

（3）箭头函数不可以被当做构造函数

（4）箭头函数不可以使用arguments对象，可以使用...args

（5）箭头函数不支持new.target

### ES6中哪个方法可以实现数组去重？

```js
const array = [1,2,3,4,5,1,2,3];
const result = Array.from(new Set(array));  // new Set(array) : Set {1,2,3,4,5}
console.log(result);  // result [1,2,3,4,5]
```

注意：ES6中实现数组去重是Array.from配合new Set

### ES6中对象新增的方法有哪些？

（1）Object.is()

三个等号无法正确判断NaN===NaN

```js
// 用来判断两个变量的类型和值是否相等
const obj = {};
const secondObj = {};
const numOne = 1;
const numTwo = 1;
const result = Object.is(obj,secondObj);
const result1 = Object.is(numOne,numTwo);
const result2 = Object.is(NaN,NaN);
console.log(result);  // false 两个引用类型的变量地址不同
console.log(result1);  // true 两个简单类型的变量，其值和变量类型都相等
console.log(result2);  // true
```

特点：

- 不仅可以对值类型进行正常处理而且对象类型的值也可以进行判断
- 对于特殊的值 NaN，也可以进行正常的处理

（2）Object.assign()

```js
// Object.assign 用于合并对象
const obj = {
    name: "freemen"
}
const objTwo = {
    age: 18
}
const result = Object.assign(obj,objTwo);
console.log(result); // {name: "freemen", age: 18}
```

（3）Object.keys()

```js
// Object.keys 返回的是目标对象所有可遍历属性的键名
const object = {
    name: "freemen",
    age: 18
}
const result = Object.keys(object); 
console.log(result);  // ["name", "age"]
```

（4）Object.values()

```js
// Object.values 返回的是目标对象所有可遍历属性的键值
const object = {
    name: "freemen",
    age: 18
}
const result = Object.values(object); 
console.log(result);  // ["freemen", 18]
```

（5）Object.entries()

```js
// Object.entries
const object = {
    name: "freemen",
    age: 18
}
const result = Object.entries(object);
console.log(result);  // [["name", "age"], ["freemen", 18]],二维数组
```

#### 面试中该如何回答该题目

Object.is()  用于比较两个值是否相等

Object.assign()  用于对象的合并，将源对象的所有可枚举属性，复制到目标对象

Object.keys()  返回一个数组，成员是参数对象自身的所有可遍历属性的键名

Object.values()  返回一个数组，成员是参数对象自身的所有可遍历属性的键值

Object.entries()  返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组

### class和function的区别

相同点：都可以用作构造函数

```js
// 函数用作构造函数的情况
function Person() {
    this.fullname = "freemen"
}
const object = new Person;
console.log(object);  // {fullname: "freemen"}
// class
class Person {
    constructor() {
        this.fullname = "freemen"
    }
}
const object = new Person;
console.log(object);  // {fullname: "freemen"}
```



不同点：class不可以使用call  apply   bind  的方式来改变他的执行上下文

```js
function sayName() {
    console.log(this.fullName);
}
const obj = {
    fullName: "freemen"
}
sayName.call(obj);  // freemen

// -------------------
class Person{
    constructor() {
        this.fullname = "freemen"
    }
}
const obj = {
    fullName: "freemen"
}
Person.cll(obj);  // Class constructor Person cannot be invoked without 'new'
```



### 你对Promise了解多少？

#### 定义

Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。

#### 基本使用

```js
// Promise有3个状态，pending正在进行中  fulfilled成功  rejected失败
new Promise(function(resolve, reject) {
    let fullName = "freemen";
    if(fullName === 'freemen') {
        resolve(1)
    }else {
        reject(2)
    }
}).then(function(value) {
    console.log(`resolve-value`,value);   // resolve-value 1
}, function(value) {
    console.log(`reject-value`,value)
})
```

#### 原型方法

（1）Promise.prototype.then

- 支持链式调用
- then 接收两个参数，且都是函数，第一个函数是Promise状态变成fulfilled时候的回调函数，第二个函数是Promise状态变成rejected时候的回调函数
- 返回值也是Promise（新的Promise）

```js
new Promise(function(resolve,reject) {
    let fullName = "freemen";
    if(fullName === 'freemen') {
        resolve(1)
    }else {
        reject(2)
    }
}).then((value)=>{
    console.log(`fulfilled-value`,value);
    return value+1;
}).then((fulfilledValue)=>{
    console.log(`fulfilled-value`,fulfilledValue);
}, (rejectedValue)=> {
    console.log(`rejectedValue`,rejectedValue);
})
// fulfilled-value 1
// fulfilled-value 2
```

（2）Promise.prototype.catch  捕获Promise错误

```js
new Promise(function(resolve,reject) {
    let fullName = "freemen";
    if(fullName === 'Vinko') {
        resolve(1)
    }else {
        reject('Promise error')
    }
}).then((value) => {
    console.log(`value`,value)
}).catch((error) => {
    console.log(`error`,error)
}) // error Promise error
```

（3）Promise.prototype.finally

用于指定不管Promise对象最后状态如何，都会执行的操作

```js
new Promise(function(resolve,reject) {
    console.log(`loading start...`)
    let fullName = "freemen";
    if(fullName === 'Vinko') {
        resolve(1)
    }else {
        reject('Promise error')
    }
}).then((value) => {
    console.log(`value`,value)
}).catch((error) => {
    console.log(`error`,error)
}).finally(()=> {
    console.log(`loading end...`)
})
// loading start...
// error promise error
// loading end...
```



#### 实例方法

（1）Promise.all

用于将多个Promise实例包装成一个新的Promise实例，并发的，每个Promise状态都发生改变才能拿到结果

```js
const promiseArray = [1,2,3,4,5].map((item)=> {
    return new Promise((resolve)=> {
        resolve(item);
    })
});
Promise.all(promiseArray).then((res)=>{
    console.log(`res`,res)
});
//res  [1,2,3,4,5]

```

（2）Promise.race

将多个Promise实例包装成一个新的Promise实例，继发的，只要有一个Promise状态发生改变，就能拿到结果

```js
const promiseArray = [1,2,3,4,5].map((item)=> {
    return new Promise((resolve)=> {
        resolve(item);
    })
});
Promise.race(promiseArray).then((res)=>{
    console.log(`res`,res)
});
// res 1
```

（3）Promise.resolve

将现有对象转化为Promise对象

```js
new Promise(function(resolve,reject) {
    console.log(`loading start...`)
    let fullName = "freemen";
    if(fullName === 'freemen') {
        resolve(1)
    }else {
        reject('Promise error')
    }
}).then(res=> {
    console.log(`res`,res)
})
//loading start...
//res 1
// ------------------等效于
Promise.resolve(1).then(res=>{
    console.log(res)
})
```

（4）Promise.reject

返回一个Promise实例，实例的状态是rejected

```js
new Promise(function(resolve,reject) {
    console.log(`loading start...`)
    let fullName = "freemen";
    if(fullName === 'Vinko') {
        resolve(1)
    }else {
        reject('Promise error')
    }
}).then(res=> {
    console.log(`res`,res)
}，rejected=> {
    console.log(`rejected`,rejected)
})
// ------------------等效于
Promise.reject('Promise error').then(null,rejected=>{
    console.log(`rejected`,rejected)
})
```

#### 面试中该如何回答该题目

- Promise的定义
- Promise的基本使用（三个状态）
- Promise原型方法
- Promise的实例方法
- 扩展至Promise的实现原理（加分项）

### 扩展运算符的实现原理

在babel的repl执行环境里面，可以看所有es6中新增特性的实现原理

```js
const baseArray = [1,2,3,4];
const array = [...baseArray];

// ---------------------
var baseArray = [1,2,3,4];
var array = [].concat(baseArray);
```

### 了解forEach、for in、for of三者区别

（1）forEach、for in、for of的使用方式

（2）forEach、for in、for of之间的区别

- forEach是数组方法

  （1）遍历的时候更加简洁，效率和for循环相同，不用关心集合下标的问题，减少了出错的概率。

  （2）没有返回值

  （3）不能使用break中断循环，不能使用return返回到外层函数

- for in用于循环遍历数组或对象属性（大部分用于对象）

- for of一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for of循环遍历它的成员，可用for of遍历的成员包括：数组，Set和Map结构，类数组对象

## Vue面试题

### Vue生命周期

**创建阶段** 

beforeCreate：实例刚在内存中创建出来，还没有初始化data和methods

created：实例已经在内存中创建完成，此时data和methods已经创建完成

beforeMount：此时已经完成了模板的编译，只是还没有渲染到界面中去

mounted：模板已经渲染到了浏览器，创建阶段结束，即将进入运行阶段

**运行阶段** 

beforeUpdate：数据更新时调用，这里适合在更新之前访问现有的DOM

updated：页面重新渲染完毕，页面中的数据和data保持一致

**销毁阶段** 

beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。

destroyed：实例销毁后调用。该钩子被调用后，对应Vue实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。

### Vue父子组件声明周期调用顺序

**加载渲染过程**

父beforeCreate→父created→父beforeMount→子beforeCreate→子created→子beforeMount→子mounted→父mounted

**子组件更新过程**

父beforeUpdate→子beforeUpdate→子updated→父updated

**父组件更新过程**

父beforeUpdated→父updated

**销毁过程**

父beforeDestroy→子beforeDestroy→子destroyed→父destroyed

### keep-alive组件

#### keep-alive组件的定义

keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会**缓存**不活动的组件实例，而不是销毁它们。

#### keep-alive组件的使用场景

首页列表激活态



### Vue中在哪个声明周期内调用异步请求

- 可以在 created、beforeMount、mounted 中调用异步请求

- 推荐在created钩子函数中调用异步请求，原因如下：

  （1）相对beforeMount、mounted能更快获取到服务端数据，减少页面loading时间

  （2）ssr不支持beforeMount、mounted钩子函数，所以放在cerated中有助于一致性

### v-if和v-show的区别

相同点：都是用来控制元素的显示与隐藏

不同点：（1）v-show不管条件是真还是假，第一次渲染的时候都会编译出来，也就是标签都会添加到DOM中。通过display属性来控制元素的显示与隐藏

（2）v-if在首次渲染的时候，如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始局部编译，动态的向DOM元素里面添加元素。当条件从真变为假的时候，开始局部编译，卸载这些元素，也就是删除。

- 性能角度

  v-show的性能高于v-if，通过display属性来控制显示隐藏仅仅会触发页面重绘

  v-if通过节点的增加/删除控制元素是否显示，会触发页面的回流

  而回流必然导致重绘

### vuex是什么？怎么使用？

Vuex是一个专为Vue.js应用程序开发的管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

#### vuex的定义

Vuex是vue的状态管理工具，用于解决vue中状态共享的问题。

- state：用于保存我们应用的状态
- mapState：处理顶层状态到组件的映射关系
- Getters：对状态进行公共的处理
- mapGetters：处理Getter到组件的映射关系
- mutations：业务组件中通过$store.commit同步修改state
- mapMutations：简化mutation的调用
- Actions：子组件中通过dispatch action异步修改应用状态
- mapActions：简化action的调用
- Modules：对store进行模块化管理

actions处理异步数据请求，mutations同步更改state状态

#### vuex的使用场景

商品列表页面添购物车的场景

## 打包工具webpack面试题

### webpack是什么

webpack是一个用于现代JavaScript应用程序的 静态模块打包工具

### webpack解决了什么问题

- 模块依赖问题
- 代码编写问题（把typeScript转为js，把less，sass转为css）
- 开发效率问题（保存文件后会自动更新，不需要手动刷新浏览器）
- 项目优化问题（项目开发完需要打包上线时，webpack可以对代码进行压缩优化，保证项目整体的性能）

### webpack中有哪些loader，分别是用来做什么的

- js相关

  （1）babel-loader：处理javaScript文件，提供语法转换，语法垫片

  （2）source-map-loader：从现有源文件中提取源映射关系

- css相关

  （1）style-loader：把编译后的css以style标签的格式插入DOM中

  （2）css-loader：处理css中比如url() @import等语法的文件引用路径问题

  （3）less-loader：将less编译为css

- 文件相关

  （1）file-loader：处理文件引用路径问题

  （2）gzip-loader：加载gzip资源

  （3）url-loader：允许有条件地将文件转换为内联的base-64 URL（减少了发送http请求的个数，提高了应用的性能）

#### loader的执行顺序

loader以数组的方式进行配置，执行的顺序是从后往前栈结构的顺序执行。

### webpack中有哪些plugin，分别是用来做什么的

（1）DllPlugin：为了极大减少构建时间，进行分离打包

（2）HotModuleReplacementPlugin：启用模块热替换

（3）HtmlWebpackPlugin：简单创建HTML文件，用于服务器访问

（4）ProvidePlugin：全局注入模块，不必通过import/require使用模块

#### plugin的执行顺序

Plugin的执行顺序无关配置顺序，可以在webpack的整个编译周期执行

### loader和plugin有什么区别

**loader本质上是一个函数**，这个函数接收source为参数，函数返回值便是我们最终loader处理的结果。

**plugin本质上是一个构造函数**，通常用class类来表示，constructor中接收入参，且必须实现apply方法来接收webpack的主体编译对象compiler

**功能**：loader做的事情  plugin也可以做

**执行顺序**：plugin可以在webpack编译的整个过程执行，类比于vue生命周期钩子。而loader只能在固定的阶段执行。

**本质上的区别**：loader本质上是一个翻译官，对客户端识别不了的源码进行翻译。plugin执行的是一些副操作(文件上传)

### webpack大致的构建流程

配置文件、shell语句 → (合并初始化参数) → 初始化compiler对象（负责文件的监听和启动编译，包含了完整的webpack配置） →  加载所有插件，依次调用插件的apply方法，并传入compiler对象  →  找到入口文件entry，建立文件依赖树 → 调用所有的loader对源文件进行翻译 → 输出生产包

## 数据结构与算法面试题

### JavaScript的数组方法有哪些？

- concat：连接2个或更多数组，并返回结果

  ```js
  const firstArray = [1,2,3,4,5];
  const secondArray = [6,7,8,9];
  const result = firstArray.concat(secondArray);
  console.log(result); // [1,2,3,4,5,6,7,8,9]
  ```

- every：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true

  ```js
  const array = [{name: 'freemen', age: 18}, {name: 'Vinko',age: 18}];
  const result = array.every((item)=> {
      return item.age === 18
  })
  console.log(result); // true
  ```

- filter：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组

  ```js
  const array = [{name: 'freemen', age: 18}, {name: 'Vinko',age: 18}];
  const result = array.filter(item=>{
      return item.name === 'freemen'
  })
  console.log(result); // [{name: 'freemen', age: 18}]
  ```

- forEach：对数组中的每一项运行给定函数，这个方法没有返回值

  ```js
  const array = [{name: 'freemen', age: 18}, {name: 'Vinko',age: 18}];
  array.forEach((item,index) => {
      console.log(item)
      console.log(index)
  })
  // {name: 'freemen', age: 18}
  // 0
  // {name: 'Vinko',age: 18}
  // 1
  ```

- join：将所有的数组元素连接成一个字符串

  ```js
  const array = [1,2,3,,4,5];
  const result = array.join(',');
  console.log(result);
  // 1,2,3,,4,5    1;2;3;4;5;
  ```

- indexOf：返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1

  ```js
  const array = [1,2,3,4];
  const result = array.indexOf(2);
  console.log(result);
  // 1
  ```

- lastIndexOf：返回在数组中搜索到的与给定参数相等的元素的索引里最大的值

  ```js
  const array = [1,2,3,3,3,3,4,5];
  const result = array.lastIndexOf(3);
  console.log(result);
  // 5
  ```

- map：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组

  ```js
  const array = [{name: 'freemen', age: 18}, {name: 'Vinko',age: 18}];
  const result = array.map(item=>{
      return item.name;
  })
  console.log(result);
  // ['freemen', 'Vinko']
  ```

- reverse：颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个元素

  ```js
  const array = [1,2,3,4,5];
  const result = array.reverse();
  console.log(result);
  // [5,4,3,2,1]
  ```

- slice：传入索引值，将数组里对应索引范围内的元素作为新数组返回

  ```js
  const array = [1,2,3,4,5];
  const result = array.slice(0,3);
  console.log(result);
  // [1,2,3]
  ```

- some：对数组中的每一项运行给定函数，如果任一项返回true，则返回true

  ```js
  const array = [1,2,3,4,5];
  const result = array.some(item=>{
      return item > 0
  })
  console.log(result)
  // true
  ```

- sort：按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数

  ```js
  const array = [1,2,3,4,5];
  const result = array.sort((a,b)=>{
      return b - a;
  })
  console.log(result);
  // [5,4,3,2,1]
  ```

- toString：将数组作为字符串返回

  ```js
  const array = [1,2,3,4,5];
  const result = array.toString();
  console.log(result);
  // 1,2,3,4,5
  ```

### 如何去除数组中指定的元素

```js
const array = [{name: 'freemen', age: 18}, {name: 'Vinko',age: 18}];
function cutArray (sourceArray, target) {
    sourceArray.forEach((item,index) =. {
                        if (item.name === target) {
        					sourceArray.splice(index,1)
                        }
    })
    return sourceArray
}
const result = cutArray(array, 'freemen');
console.log(result);
```

### 对于栈的了解

#### 栈的定义

栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素就接近栈底。

#### 栈的创建

```js
function Stack() {
    this.items = [];
}
// 添加元素的方法
Stack.propotype.push = function(element) {
    this.items.push(element)
}
// 移除栈顶的元素
Stack.propotype.pop = function() {
    this.items.pop()
}
// 拿栈顶的元素
Stack.propotype.peek = function() {
    return this.items[this.items.length - 1]
}
// 判断栈是否为空
Stack.propotype.isEmpty = function() {
    return this.items.length === 0
}
// 清除栈
Stack.propotype.clear = function() {
    this.items = [];
}
const stack = new Stack();
stack.push({number: 1})
stack.push({number: 2})
stack.push({number: 3})
stack.push({number: 4})
stack.push({number: 5})
console.log(stack); 
/* Stack {
	items: [
        {number: 1},
        {number: 2},
        {number: 3},
        {number: 4},
        {number: 5}
    ]
} */
stack.pop(); // 移除栈顶元素
console.log(stack); 
/* Stack {
	items: [
        {number: 1},
        {number: 2},
        {number: 3},
        {number: 4}
    ]
} */
const result = stack.peek();
console.log(result);  // {number: 4}
const empty = stack.isEmpty();
console.log(empty);  // false
stack.clear();
const empty1 = stack.isEmpty();
console.log(empty1);  // true
```

#### 栈在实际项目中的运用

### 对于队列的了解

#### 队列的定义

队列是遵循先进先出原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。

#### 队列的创建

```js
// 队列的实现
function Queue() {
    this.items = [];
}
// 添加元素
Queue.prototype.enqueue = function(element) {
    this.items.push(element);
}
// 删除元素
Queue.prototype.dequeue = function() {
    return this.items.shift();
}
// 返回队列中第一个元素
Queue.prototype.front = function() {
    return this.items[0];
}
// 判断队列是否为空
Queue.prototype.isEmpty = function() {
    return this.items.length===0;
}
// 清空队列
Queue.prototype.clear = function() {
    this.items.length = 0;
}
// 获取队列的长度
Queue.prototype.size = function() {
    return this.items.length;
}
// 打印队列中元素
Queue.prototype.print = function() {
    console.log(this.items.toString());
}

var queue = new Queue();
console.log(queue.isEmpty());  // true
queue.enqueue("freemen");
queue.enqueue("vinko");
queue.enqueue("andy");
queue.print(); // freemen,vinko,andy
console.log(queue.size());  // 3
console.log(queue.isEmpty());  // false
queue.dequeue();
queue.dequeue();
queue.print();  // andy
```

#### 队列在实际项目中的运用

react-redux中用到队列

### 冒泡排序

```js
// 冒泡排序 比较任何两个相邻的项，如果第一个比第二个大，
// 则交换它们。元素项向上移至 正确的顺序
// 就好像气泡升至表面一样，冒泡排序因此得名
// [1,2,3,4,5,9,8,7,6]
const array = [1,2,3,4,5,9,8,7,6];
const bubbleSort = (array) => {
    const length = array.length;
    for(let i = 0; i < length; i++) {
        for(let j = 0; j < length - 1; j++) {
            if (array[j] > array[j+1]) {
                var aux = array[j];
                array[j] = array[j+1];
                array[j+1] = aux;
            }
        }
    }
    return array;
}
const result = bubbleSort(array); 
console.log(result); // [1,2,3,4,5,6,7,8,9]
```

## 设计模式

### 装饰者模式

在不改变对象自身代码的基础上新增功能

```js
let a = () => {
    console.log('a');
}
// 违背了开闭原则
/* let newa = () =>{
    console.log('a');
    console.log('b');
}
newa(); */
// 没有改变a函数
let newa = () => {
    a();
    console.log('b');
}
newa();  // a b

// 飞机大战  发射普通子弹  发射导弹  发射原子弹
function Plane() {
    
}
Plane.prototype.fire = function() {
    console.log('普通子弹');
}
function MissileDecorator(plane) {
    this.plane = plane;
}
MissileDecorator.prototype.fire = function() {
    this.plane.fire();
    console.log('导弹');
}
function AtomDecorator(plane) {
    this.plane = plane;
}
AtomDecorator.prototype.fire = function() {
    this.plane.fire();
    console.log('原子弹');
}
let plane = new Plane();
plane = new MissileDecorator(plane);
plane = new AtomDecorator(plane);
plane.fire();  // 普通子弹  导弹  原子弹
```

### 策略模式

有效地解决if else 逻辑复杂不可维护的情况

```js
// s a b c d
// 5 4 3 2 1
function calculateBonus(base,grade) {
    if (grade==='s') {
        console.log('iphine');
        return base*5;
    }else if(grade==='a') {
        console.log('书包');
        return base*4;
    }else if(grade==='b') {
        console.log('对联');
        return base*3;
    }else if(grade==='c') {
        return base*2;
    }else {
        return base*1;
    }
}
const result = calculateBonus(1000,'s');
console.log(result);  // 5000
const resulta = calculateBonus(2000,'a');
console.log(resulta);  // 8000

// 使用策略模式实现发放年终奖
let strategys = {
    s(base) {
        console.log('女朋友');
        console.log('iphone');
        return base*5;
    },
    a(base) {
        return base*4;
    },
    b(base) {
        return base*3;
    },
    c(base) {
        return base*2;
    },
    d(base) {
        return base;
    },
    e(base) {
        return 0;
    }
}
function calculateBonus(base,grade) {
    return strategys[grade](base)
}
```

### 代理模式

转发请求

```js
// 情景剧：梁山伯与祝英台的故事
// 梁山伯把玫瑰送给媒婆，并委托替他向祝英台表白
function Flower(owner,name) {
    this.owner = owner;
    this.name = name;
}
let lianShanbo = {
    sendFlower(target) {
        let flower = new Flower('lianShanbo','rose');
        target.receiveFlower(flower);
    }
}
let matchMaker = {
    receiveFlower(flower) {
        ZhuYingTai.receiveFlower(flower);
    }
}
let zhuYingTai = {
    receiveFlower(flower) {
        console.log(`zhuYingTai receive ${flower.name} from ${flower.owner}`);
    }
}
lianShanbo.sendFlower(matchMaker); // zhuYingTai receive rose from liangShanbo
```

### 发布订阅模式

发布-订阅模式又叫 观察者模式

它定义对象间的一种一对多的依赖关系

当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知

```js
// 用户就是发布者 document绑定的click事件是监听者
document.addEventListener('click',(event)=>{
    console.log(event);
})
```

```js
// 顾客购买iphone13
class Apple{
    constructor() {
        this.queue = [];
    }
    push(obj) {
        this.queue.push({
            name: obj.name,
            fn: obj.fn
        });
        
    }
    publish() {
        this.queue.forEach((item)=>{
            items.fn(item.name)
        })
    }
}
const apple = new Apple();
apple.push({
    name: "freemen",
    fn(name) {
        console.log(`${name} reveive iphone13`);
        console.log(`真香`);
    }
})
apple.push({
    name: "vinko",
    fn(name) {
        console.log(`${name} reveive iphone13`);
        console.log(`太香了`);
    }
})
apple.publish(); freemen reveive iphone13 真香  vinko reveive iphone13 太香了
```

### 迭代器模式

```js
const array = [1,2,3,4,5];
// forEach 迭代器模式 最基础应用
array.forEach((item,index)=>{
    console.log(`item: ${item}`);
    console.log(`index: ${index}`);
})
```

```js
// 倒序迭代器
let reverseEach = function(obj,callback) {
    if(Array.isArray(obj)) {
        throw Error('params is must not be an array!');
    }
    for(let i = obj.length-1; i>=0;i--) {
        callback.call(obj[i],obj[i],i)
    }
}
reverseEach(array,(item,index)=>{
     console.log(`item: ${item}`);
     console.log(`index: ${index}`);
})
```

## 网络协议面试题及实操

### http常见的状态码及含义

200：请求成功

301：永久重定向

302：临时重定向

403：没权限

404：表示服务器上没有找到该资源

500：服务器错误

### http有哪些请求方法？GET和POST有什么区别？

**http请求方法：**

- GET
- POST
- PUT
- DELETE

**get和post有什么区别？**

- get用来获取数据，post用来提交数据
- get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制。
- get是明文传输，post是放在请求体中

### http协议中的header及含义

accept：代表客户端希望接受的数据类型

accept-encoding：浏览器发给服务器，声明浏览器支持的编码类型

accept-language：表示浏览器所支持的语言类型

Cache-Control：缓存开关，no-cache：表示禁用缓存

referer：referer的正确英语拼法是refereer。由于早期HTTP规范的拼写错误，主要用于防止盗链和恶意请求

## 浏览器面试题

### 浏览器的事件传输机制原理

背景：事件传输机制 冒泡 和捕获 分别由 微软和网景公司提出

这两个概念都是为了解决页面中事件流（事件发生顺序）的问题

### 事件触发的三个阶段

- 捕获阶段
- 目标阶段
- 冒泡阶段

### localStorage和sessionStorage的区别

相同点：

1、localStorage和sessionStorage同属于web存储的范畴

2、用于存储客户端的本地数据

区别：

1、数据声明周期：localStorage除非被清除，否则一直存在，sessionStorage页面关闭就清理

2、数据存储大小：localStorage 5M，sessionStorage  5M(标准浏览器下都是5M)

### 你对浏览器的事件循环机制了解多少？

#### 宏任务、微任务有哪些

宏任务：script(整个代码段)、setTimeout、setInterval、setimmediate、I/O、UI render

微任务：process.nextTick、Promise、Async/Await、MutationObserver（html5新特性）

#### 事件循环机制的执行过程是怎样的

- 执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环

```js
console.log('script start');
setTimeout(function() {
    console.log('setTimeout')
},0);

new Promise((resolve)=>{
    console.log('promise one');
    resolve(1);
    console.log('promise then')
}).then(res=>{
    console.log('promise two');
})
console.log('script end');
// script start
// promise one
// promise then
// script end
// promise two
// setTimeout
```



### 浏览器的回流和重绘

#### 浏览器的渲染过程

1、解析HTML，生成DOM树，解析CSS，生成CSSOM树

2、将DOM树和CSSOM树结合，生成渲染树(Render Tree)

3、Layout(回流)：根据生成的渲染树，进行回流(Layout)，得到节点的几何信息(位置，大小)

4、Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素

5、调用GPU触发渲染，将结果展示在页面上

#### 回流和重绘的概念

回流：通过构造渲染树，将可见DOM节点以及它对应的样式结合起来，可是还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算阶段就是回流。

（重新绘制整个页面，包括整个结构和样式）

重绘：通过构造渲染树，知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息（位置、大小），那就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。

（重新绘制当前页面样式）

#### 软件工程和建筑学的渊源

软件设计中的设计模式源于建筑学

回流：相当于把房子拆了重建

重绘：相当于重新粉刷

结论：回流必然导致重绘，重绘不一定会伴随着回流

#### 何时触发回流和重构

1、添加或删除可见的DOM元素

2、元素的内容、位置或尺寸发生变化

3、页面一开始渲染的时候

4、浏览器的窗口尺寸变化

#### 如何避免回流和重绘

1、最小化回流和重绘的次数

```js
const ele = document.getElementById('render');
ele.style.padding = '10px';
ele.style.borderLeft = '10px';
ele.style.borderRight = '10px';

const ele = document.getElementById('render');
ele.style.cssText += 'padding: 10px; border-left: 10px; border-right: 10px;';
```

2、使用文档片段fragment

```js
<ul id="list"></ul>
<script>
    const list = document.querySelector('#list');
	const fruits = ['Apple', 'Orange', 'Banana', 'Melon'];
	const fragment = document.cerateDocumentFragment();
	fruits.forEach(fruit => {
        const li = document.createElement('li');
        li.innerHTML = fruit;
        fragment.appendChild(li);
    });
	list.appendChild(fragment);
</script>
```



### 跨域

#### 什么是浏览器的同源策略

同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交换。它能帮助阻隔恶意文档，减少可能被攻击的媒介。

如果两个URL的protocol协议、port(en-US)端口（如果有指定的话）和host主机都相同的话，则这两个URL是同源。

#### 什么是跨域

当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为**跨域**。

#### 跨域的常见解决方案

- jsonp

  原理：利用< script >标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据。JSONP请求一定需要对方的服务器做支持才可以。

  优点：JSON优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。

  缺点：仅支持get方法具有局限性，不安全可能或遭受XSS攻击。

- postMessage

  是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题

  （1）页面和其打开的新窗口的数据传递

  （2）多窗口之间消息传递

  （3）页面与嵌套的iframe消息传递

  （4）上面三个场景的跨域数据传递

- nginx反向代理

  需要搭建一个中转nginx服务，用于转发请求

  ```js
  server {
      listen 80;
      server_name www.imooc.com;
      location / {
          proxy_pass http://www.domain2.com:8080; #反向代理
      }
  }
  ```

  

### 浏览器的主要组成部分

- 用户界面：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
- 浏览器引擎：在用户界面和呈现引擎之间传送指令。
- 渲染引擎：负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。
- 网络模块：用于网络调用，比如HTTP请求。其接口与平台无关，并为所有平台提供底层实现。
- 用户界面后端：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
- javascript解析器：用于解析和执行JavaScript代码。
- 数据存储模块：这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookie SessionStorage LocalStorage

### 从输入一个URL到页面展示整个过程中发生了什么？

## 简历准备

#### 有哪些靠谱的简历投递渠道

- 朋友内推
- 招聘软件：BOSS直聘、拉钩
- 关注各公司招聘公众号

#### 无项目经验or项目经验少会被刷掉吗

该如何准备项目经验

1、准备1-2个实际做过的或者可以讲清楚整个业务流程的项目

2、说清楚其中作用的技术栈

3、讲清楚在项目开发过程中遇到的难点

4、复盘整个过程发掘出可以优化的地方









